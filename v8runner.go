package v8runner

import (
	"./v8platform"
	"./v8run"
	"./v8tools"
	log "github.com/sirupsen/logrus"
)

// The error built-in interface type is the conventional interface for
// representing an error condition, with the nil value representing no error.
type Error interface {
	Error() string
}

var (
	tempFiles []string
	//tempDir   string = v8tools.ИницализороватьВременныйКаталог()
)

type Конфигуратор interface {
	конфигураторИнтерфейсЗапускателя
	процедурыСозданияБазы
	процедурыЗагрузкиКонфигурации
	дополнительныеОбработчики
}

type конфигураторИнтерфейсЗапускателя interface {
	ПолучитьКонтекст() *v8run.Контекст
	УстановитьВерсиюПлатформы(строкаВерсияПлатформы string)
	УстановитьКлючСоединенияСБазой(КлючСоединенияСБазой string)
	КлючСоединенияСБазой() string
	СтандартныеПараметрыЗапускаКонфигуратора() (p []string)
	ВыполнитьКоманду(args []string) (e error)
	ПроверитьВозможностьВыполнения() (ok bool, err error)
}

type конфигуратор struct {
	v8run.ЗапускательКонфигуратора
	ВременнаяБаза *ВременнаяБаза
}

// new func

func НовыйКонфигуратор() (conf *конфигуратор) {

	conf = &конфигуратор{}
	conf.Контекст = v8run.НовыйКонтекст()
	conf.ФайлИнформации = v8tools.НовыйФайлИнформации()
	conf.ВерсияПлатформы = v8platform.ПолучитьВерсиюПоУмолчанию()
	conf.ВременнаяБаза = НоваяВременнаяБаза(v8tools.ВременныйКаталогСПрефисом(v8tools.TempDBname))
	conf.УстановитьКлючСоединенияСБазой(conf.КлючВременногоСоединенияСБазой())
	return conf
}

func НовыйКонфигураторСКонтекстом(ctx *v8run.Контекст) (conf *конфигуратор) {

	conf = НовыйКонфигуратор()
	conf.Контекст = ctx

	return conf
}

func НовыйКонфигураторСОпциями(opts ...func(*конфигуратор)) (conf *конфигуратор) {

	conf = НовыйКонфигуратор()

	for _, opt := range opts {
		opt(conf)
	}

	return conf

}

func (conf *конфигуратор) КлючВременногоСоединенияСБазой() string {

	//conf.Контекст.ВременнаяБаза = НоваяВременнаяБаза(tempDBPath)

	log.Debugf("Получение временного ключа соединения с базой: %s", conf.ВременнаяБаза.КлючСоединенияСБазой)

	return conf.ВременнаяБаза.КлючСоединенияСБазой
}

func (conf *конфигуратор) ВыполнитьКоманду(args []string) (e error) {

	if ok, err := conf.ПроверитьВозможностьВыполнения(); !ok {
		e = err
		return
	}

	e = conf.ЗапускательКонфигуратора.ВыполнитьКоманду(args)

	return
}

func (c *конфигуратор) ПроверитьВозможностьВыполнения() (ok bool, err error) {

	ok = true

	log.Debugf("КлючСоединенияСБазой: %s", c.КлючСоединенияСБазой())
	log.Debugf("ВременныйКлючСоединенияСБазой: %s", c.КлючВременногоСоединенияСБазой())
	log.Debugf("ВременнаяБазаСуществует: %v", c.ВременнаяБаза.Cуществует)

	if len(c.КлючСоединенияСБазой()) == 0 || c.КлючСоединенияСБазой() == c.КлючВременногоСоединенияСБазой() {

		if !c.ВременнаяБаза.Cуществует {

			c.ВременнаяБаза.ИнициализироватьВременнуюБазу()
		}

	}

	ok, err = c.ЗапускательКонфигуратора.ПроверитьВозможностьВыполнения()

	return

}

func ФайлИнформации(файлИнформации string) func(*конфигуратор) {
	return func(s *конфигуратор) {
		s.ФайлИнформации = файлИнформации
	}
}
